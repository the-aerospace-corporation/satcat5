--------------------------------------------------------------------------
-- Copyright 2024-2025 The Aerospace Corporation.
-- This file is a part of SatCat5, licensed under CERN-OHL-W v2 or later.
--------------------------------------------------------------------------
-- SGMII port using Microsemi's XCVR Transceivers in raw mode
--
-- Requires Mircosemi IP generated by project/libero/ipcores/sgmii_xcvr.tcl.
--
-- This module uses the Microsemi "Transceiver Interface", "Transmit PLL", and
-- "Transceiver Reference Clock" IP-cores. The Transceiver interface is set up
-- in raw mode (i.e., The transceiver silicon is used for serialization and CDR
-- only.) All 8b/10b and SGMII logic is implemented using existing SatCat5
-- infrastructure. This consumes additional fabric resources, but allows
-- sub-nanosecond timestamp accuracy for PTP.
--
-- See also Microsemi documentation:
--  * AN4623 Appendix 4: 1G Ethernet Using Transceiver
--  * UG0687: 1G Ethernet Solutions User Guide
--  * UG0677: Transceiver User Guide
--  * AN4662: PolarFire Transceiver Demo
--

library ieee;
use     ieee.std_logic_1164.all;
use     ieee.numeric_std.all;
use     work.common_functions.all;
use     work.common_primitives.all;
use     work.eth_frame_common.all;
use     work.ptp_types.all;
use     work.switch_types.all;

entity port_sgmii_raw is
generic (
    LANES       : integer := 1;         -- Number of port lanes to generate
    SHAKE_WAIT  : boolean := false;     -- Wait for MAC/PHY handshake?
    VCONFIG     : vernier_config := VERNIER_DISABLED);
port (
    -- Clocking and reset
    clk_40      : in  std_logic; -- 40MHz For Enhanced Receiver Management (ERM)
    refclk_p    : in  std_logic;
    refclk_n    : in  std_logic;
    reset_p     : in  std_logic;

    -- External SGMII interfaces (direct to MGT pins)
    sgmii_rxp   : in  std_logic_vector(LANES-1 downto 0);
    sgmii_rxn   : in  std_logic_vector(LANES-1 downto 0);
    sgmii_txp   : out std_logic_vector(LANES-1 downto 0);
    sgmii_txn   : out std_logic_vector(LANES-1 downto 0);

    -- Generic internal port interfaces.
    prx_data    : out array_rx_m2s (LANES-1 downto 0);
    ptx_data    : in  array_tx_s2m (LANES-1 downto 0);
    ptx_ctrl    : out array_tx_m2s (LANES-1 downto 0);
    quad_shdn   : in  std_logic;
    lane_shdn   : in  std_logic_vector (LANES-1 downto 0);
    lane_test   : in  std_logic_vector (LANES-1 downto 0) := (others => '0');

    -- Global reference for PTP timestamps, if enabled.
    ref_time    : in  port_timeref := PORT_TIMEREF_NULL);
end port_sgmii_raw;

architecture microsemi of port_sgmii_raw is

-- Clocking and reset.
signal reset_n          : std_logic;
signal xcvr_ref_clk     : std_logic;
signal tx_bit_clk       : std_logic;
signal txpll_lock       : std_logic;
signal txpll_ref_clk    : std_logic;
signal lane_reset_async : std_logic_vector(LANES-1 downto 0);

-- Array types for PTP timestamps.
type array_tstamp is array(natural range<>) of tstamp_t;
type array_tfreq is array(natural range<>) of tfreq_t;

-- Transmit datapath.
signal tx_clk125        : std_logic_vector(LANES-1 downto 0);
signal tx_data10        : std_logic_vector(10*LANES-1 downto 0);
signal tx_tstamp        : array_tstamp(LANES-1 downto 0)
                            := (others => TSTAMP_DISABLED);
signal tx_tfreq         : array_tfreq(LANES-1 downto 0)
                            := (others => TFREQ_DISABLED);
signal tx_tvalid        : std_logic_vector (LANES-1 downto 0)
                            := (others => '0');
signal tx_locked        : std_logic_vector(LANES-1 downto 0);

-- Receive datapath.
signal rx_clk125        : std_logic_vector(LANES-1 downto 0);
signal rx_reset_async   : std_logic_vector(LANES-1 downto 0);
signal rx_reset_sync    : std_logic_vector(LANES-1 downto 0); -- Clk: rx_clk125
signal rx_data10        : std_logic_vector(10*LANES-1 downto 0);
signal rx_locked        : std_logic_vector(LANES-1 downto 0);
signal rx_valid         : std_logic_vector(LANES-1 downto 0);
signal rx_tstamp        : array_tstamp(LANES-1 downto 0)
                            := (others => TSTAMP_DISABLED);
signal rx_tfreq         : array_tfreq(LANES-1 downto 0)
                            := (others => TFREQ_DISABLED);
signal rx_tvalid        : std_logic_vector (LANES-1 downto 0)
                            := (others => '0');

-- Microsemi IP: PF_XCVR_REF_CLK:1.0.103
component PF_XCVR_REF_CLK_SGMII
port (
    REF_CLK_PAD_P       : in  std_logic;
    REF_CLK_PAD_N       : in  std_logic;
    REF_CLK             : out std_logic);
end component;

-- Microsemi IP: PF_TX_PLL:2.0.304
component PF_TX_PLL_SGMII
port (
    REF_CLK             : in  std_logic;
    PLL_LOCK            : out std_logic;
    BIT_CLK             : out std_logic;
    LOCK                : out std_logic;
    REF_CLK_TO_LANE     : out std_logic;
    CLK_125             : out std_logic);
end component;

-- Microsemi IP: PF_XCVR_ERM:3.1.205
component PF_XCVR_ERM_SGMII
port (
    CTRL_CLK            : in  std_logic;
    CTRL_ARST_N         : in  std_logic;
    LANE0_CDR_REF_CLK_0 : in  std_logic;
    LANE0_LOS           : in  std_logic;
    LANE0_PCS_ARST_N    : in  std_logic;
    LANE0_PMA_ARST_N    : in  std_logic;
    LANE0_RXD_N         : in  std_logic;
    LANE0_RXD_P         : in  std_logic;
    LANE0_RX_SLIP       : in  std_logic;
    LANE0_TX_DATA       : in  std_logic_vector (9 downto 0);
    LANE0_TX_ELEC_IDLE  : in  std_logic;
    LANE0_RX_BYPASS_DATA : out std_logic;
    LANE0_RX_CLK_R      : out std_logic;
    LANE0_RX_DATA       : out std_logic_vector (9 downto 0);
    LANE0_RX_IDLE       : out std_logic;
    LANE0_RX_READY      : out std_logic;
    LANE0_RX_VAL        : out std_logic;
    LANE0_TXD_N         : out std_logic;
    LANE0_TXD_P         : out std_logic;
    LANE0_TX_CLK_R      : out std_logic;
    LANE0_TX_CLK_STABLE : out std_logic;
    TX_BIT_CLK_0        : in  std_logic;
    TX_PLL_LOCK_0       : in  std_logic;
    TX_PLL_REF_CLK_0    : in  std_logic);
end component;

begin

-- Clocking and reset
reset_n <= not reset_p;

-- All share a reference clock, must be connected to differential pads.
u_xcvr_ref_clk : PF_XCVR_REF_CLK_SGMII
port map(
    REF_CLK_PAD_P       => refclk_p,
    REF_CLK_PAD_N       => refclk_n,
    REF_CLK             => xcvr_ref_clk);

-- All share a PLL, can use either TXPLL or the quad TXPLL_SSC.
u_tx_pll : PF_TX_PLL_SGMII
port map(
    REF_CLK             => xcvr_ref_clk,
    PLL_LOCK            => open,
    BIT_CLK             => tx_bit_clk,
    LOCK                => txpll_lock,
    REF_CLK_TO_LANE     => txpll_ref_clk,
    CLK_125             => open);

-- Generate one or more lanes with transceiver, timestamping, and SGMII logic.
gen_lanes : for n in 0 to LANES-1 generate

    -- Generate a synchronous reset for the PTP timestamping logic
    rx_reset_async(n) <= reset_p or not rx_locked(n);
    lane_reset_async(n) <= rx_reset_async(n) or not tx_locked(n);
    sync_reset_rx : sync_reset
    port map(
        in_reset_p  => rx_reset_async(n),
        out_reset_p => rx_reset_sync(n),
        out_clk     => rx_clk125(n));

    -- Timestamps for each clock domain, if enabled.
    -- TODO: Timestamping is untested as of Feb. 2025.
    gen_tstamp : if VCONFIG.input_hz > 0 generate
        u_rx_tstamp : entity work.ptp_counter_sync
        generic map(
            VCONFIG     => VCONFIG,
            USER_CLK_HZ => 125_000_000)
        port map(
            ref_time    => ref_time,
            user_clk    => rx_clk125(n),
            user_ctr    => rx_tstamp(n),
            user_freq   => rx_tfreq(n),
            user_lock   => rx_tvalid(n),
            user_rst_p  => rx_reset_sync(n));

        u_tx_tstamp : entity work.ptp_counter_sync
        generic map(
            VCONFIG     => VCONFIG,
            USER_CLK_HZ => 125_000_000)
        port map(
            ref_time    => ref_time,
            user_clk    => tx_clk125(n),
            user_ctr    => tx_tstamp(n),
            user_freq   => tx_tfreq(n),
            user_lock   => tx_tvalid(n),
            user_rst_p  => rx_reset_sync(n));
    end generate;

    -- Connect 8b/10b signals to the SatCat5 port interface. Also includes
    -- preamble insertion, rate-detect state machine, etc. Note that
    -- port_sgmii_common already uses reset synchronizers for all resets.
    u_sgmii : entity work.port_sgmii_common
    generic map(
        MSB_FIRST   => false,
        SHAKE_WAIT  => SHAKE_WAIT)
    port map(
        tx_clk      => tx_clk125(n),
        tx_data     => tx_data10((n+1)*10-1 downto n*10),
        tx_tstamp   => tx_tstamp(n),
        tx_tfreq    => tx_tfreq(n),
        tx_tvalid   => tx_tvalid(n),
        port_test   => lane_test(n),
        rx_clk      => rx_clk125(n),
        rx_lock     => rx_locked(n),
        rx_data     => rx_data10((n+1)*10-1 downto n*10),
        rx_tstamp   => rx_tstamp(n),
        rx_tfreq    => rx_tfreq(n),
        rx_tvalid   => rx_tvalid(n),
        prx_data    => prx_data(n),
        ptx_data    => ptx_data(n),
        ptx_ctrl    => ptx_ctrl(n),
        reset_p     => lane_reset_async(n));

    -- Transceiver performs CDR but not 8b/10b decode.
    u_xcvr : PF_XCVR_ERM_SGMII
    port map(
        -- Enhanced Receiver Management (ERM) must run at 40MHz
        CTRL_CLK                => clk_40,
        CTRL_ARST_N             => reset_n, -- Async, shared with PCS/PMA
        -- Shared clocks
        TX_BIT_CLK_0            => tx_bit_clk,
        TX_PLL_LOCK_0           => txpll_lock,
        TX_PLL_REF_CLK_0        => txpll_ref_clk,
        -- Lane 0 Inputs
        LANE0_CDR_REF_CLK_0     => xcvr_ref_clk,
        LANE0_LOS               => '0',
        LANE0_PCS_ARST_N        => reset_n,
        LANE0_PMA_ARST_N        => reset_n,
        LANE0_RXD_N             => sgmii_rxn(n),
        LANE0_RXD_P             => sgmii_rxp(n),
        LANE0_RX_SLIP           => '0',
        LANE0_TX_DATA           => tx_data10((n+1)*10-1 downto n*10),
        LANE0_TX_ELEC_IDLE      => lane_shdn(n),
        -- Lane 0 Outputs
        LANE0_RX_BYPASS_DATA    => open,
        LANE0_RX_CLK_R          => rx_clk125(n),
        LANE0_RX_DATA           => rx_data10((n+1)*10-1 downto n*10),
        LANE0_RX_IDLE           => open,
        LANE0_RX_READY          => rx_locked(n),
        LANE0_RX_VAL            => rx_valid(n),
        LANE0_TXD_N             => sgmii_txn(n),
        LANE0_TXD_P             => sgmii_txp(n),
        LANE0_TX_CLK_R          => tx_clk125(n),
        LANE0_TX_CLK_STABLE     => tx_locked(n));
end generate;

end microsemi;
